<!DOCTYPE html>
<html>
<head>
	<title>Project 2</title>
	<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- 	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js">
</script>
	<style>

.links line {
	stroke: #999;
	stroke-opacity: 0.6;
}

.nodes circle {
	stroke: #fff;
	stroke-width: 1.5px;
}

text {
	text-align: center;
	dominant-baseline: middle;
}

.node_text {
  pointer-events: none;
  font: 10px sans-serif;
  fill: black;
}

/*body {
	background-color: #2d3a47;
}*/
#title{
	text-align: center;
}
</style>
</head>
<body>
	<h1 id="title">StackOverFlow Tags</h1>
	<div>
		<h3>Intro</h3>
		<p>This is our project.
		Hover and click to see more.</p>
	</div>
	<div style="display: flex;" >
		<svg  width="1060" height="900"></svg>
		<div  id="legend-container">
			<p>legend here</p>
			<svg width="400" height="500" id="legendsvg">
		</div>
	</div>

	<svg width="1060" height="900" id="bar-chart"></svg>

	<script type="text/javascript">

/*
legend 
*/
// var nodeSize = d3.scaleSqrt().domain([20.0219326983115,126.571127129727]).range([10, 35]);

var svglegend = d3.select("#legendsvg");

// svglegend.append("g")
//   .attr("class", "legendSize")
//   .attr("transform", "translate(20, 40)");

// var legendSize = d3.legendSize()
//   .scale(nodeSize)
//   .shape('circle')
//   .shapePadding(15)
//   .labelOffset(20)
//   .orient('horizontal');

// svglegend.select(".legendSize")
//   .call(legendSize);


// var ordinal = d3.scaleOrdinal()
//   .domain(["General Programming", "Database/Backend", "Web Server", "Mobile App", "Shell","Front-End","Web","Java related", "Cloud Computing", "Distributed Systems", "Testing", "agile", "perl/regex", "excel"])
//   .range(d3.schemeCategory20.slice(0,15));

//   svglegend.append("g")
//   .attr("class", "legendOrdinal")
//   .attr("transform", "translate(20,20)");

// var legendOrdinal = d3.legendColor()
//   //.shape("path", d3.legendSymbol().type("triangle-up").size(150)())
//   .shapePadding(10)
//   .scale(ordinal);

// svglegend.select(".legendOrdinal")
//   .call(legendOrdinal);          


         
// var lineSize = d3.scaleLog().domain([20.02193,126.57112]).range([1, 13]);

// svglegend.append("g")
//   .attr("class", "legendSizeLine")
//   .attr("transform", "translate(20, 120)");

// var legendSizeLine = d3.legendSize()
//       .scale(lineSize)
//       .shape("line")
//       .orient("horizontal")
//       //otherwise labels would have displayed:
//       // 0, 2.5, 5, 10
//       .labels(["tiny", "small", "medium", "large", "grand"])
//       .labelWrap(30)
//       .shapeWidth(40)
//       .labelAlign("start")
//       .shapePadding(10);

// svglegend.select(".legendSizeLine")
//   .call(legendSizeLine);







         
var lineSize = d3.scaleLinear().domain([20.02193,126.57112]).range([1, 13]);


svglegend.append("g")
  .attr("class", "legendSizeLine")
  .attr("transform", "translate(0, 20)");

var legendSizeLine = d3.legendSize()
      .scale(lineSize)
      .shape("line")
      .orient("horizontal")
      //otherwise labels would have displayed:
      // 0, 2.5, 5, 10
      .labels(["tiny testing at the beginning",
        "small", "medium", "large", "grand"])
      .labelWrap(30)
      .shapeWidth(40)
      .labelAlign("start")
      .shapePadding(10);

svglegend.select(".legendSizeLine")
  .call(legendSizeLine);
         






var svg = d3.select("svg");



          


var svg = d3.select("svg"),
		width = +svg.attr("width"),
		height = +svg.attr("height");

var linksBySkill;

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
	.force("link", d3.forceLink()
		.id(function(d) { 
			return d.name; 
		})
		.distance(90)
	)
	
	.force("charge", d3.forceManyBody())
	.force("center", d3.forceCenter(width / 2, height / 2));


d3.csv("stack_network_links.csv", function(error, links) {
	
	if (error) throw error;
	d3.csv("stack_network_nodes.csv", function(error, nodes){
		
		links.forEach(function(d) {
			d.value = Number(d.value);
		})
		var lscale = d3.scaleLog()
		  .domain(d3.extent(links, d => d.value))
		  .range([1, 13]);

		var link = svg.append("g")
			.attr("class", "links")
			.selectAll("line")
			.data(links)
			.enter().append("line")
				.attr("stroke-width", function(d) { return lscale(d.value); });
		// console.log(nodes)
		// var label = svg.selectAll(null)
  //   		.data(nodes)
		//     .enter()
		//     .append("text")
		//     .text(function (d) { return d.name; })
		//     .style("text-anchor", "middle")
		//     .style("fill", "#555")
		//     .style("font-family", "Arial")
		//     .style("font-size", 12);



		nodes.forEach(function(d) {
			d.nodesize = Number(d.nodesize);
		})
		var rscale = d3.scaleSqrt()
		  .domain(d3.extent(nodes, d => d.nodesize))
		  .range([10, 35]);

		// var node = svg.append("g")
		// 	.attr("class", "nodes")
		// 	.selectAll("circle")
		// 	.data(nodes)
		// 	.enter()
		// 		.append("circle")
		// 			.attr("r", function(d) { return rscale(d.nodesize) })
		// 			.attr("fill", function(d) { return color(d.group); })
		// 			.call(d3.drag()
		// 					.on("start", dragstarted)
		// 					.on("drag", dragged)
		// 					.on("end", dragended));

		//console.log(nodes[0]);
		var node = svg.selectAll(".nodes")
			.data(nodes)
			.enter().append("g")
			//.attr("class", "nodes")
			.attr("id", d => "node_"+ d.name.replace(/\W/g, "_"))
			.call(d3.drag()
				.on("start", dragstarted)
				.on("drag", dragged)
				.on("end", dragended));

		node.append("circle")
			.attr("id", d => "node_"+ d.name.replace(/\W/g, "_")+"_circle")
			.attr("r", function(d) { return rscale(d.nodesize) })
			.attr("fill", function(d) { return color(d.group); });

/*		node.append("text")
		    .attr("dx", d => rscale(d.nodesize)+1)
		    .attr("dy", 0)
		    .text(d => d.name[0].toUpperCase()+d.name.substring(1));*/
		// node.append("title")
			// .text(function(d) { return d.name; })

		simulation
				.nodes(nodes)
				.force("collide", d3.forceCollide(d => rscale(d.nodesize + 100)))
				.on("tick", ticked);

	    simulation.force("link")
	        .links(links);


		function ticked() {
			// node
			// 	.attr("cx", function(d) { 
			// 		var upper = Math.min(width-rscale(d.nodesize), d.x);
			// 		d.x = Math.max(0+rscale(d.nodesize), upper);
			// 		return d.x;
			// 	})
			// 	.attr("cy", function(d) { 
			// 		var upper = Math.min(height-rscale(d.nodesize), d.y);
			// 		d.y = Math.max(0+rscale(d.nodesize), upper);
			// 		return d.y; 

			// 	});
			
			node.attr("transform", function (d) {
				var upperx = Math.min(width-rscale(d.nodesize), d.x);
				d.x = Math.max(0+rscale(d.nodesize), upperx);
				var uppery = Math.min(height-rscale(d.nodesize), d.y);
				d.y = Math.max(0+rscale(d.nodesize), uppery);

                return "translate(" + d.x + "," + d.y + ")";
                });

			link
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });

		}

		// Get linked skills by specific skill   
	    function findSkill(skill) {
			var linksData = [];
			links.forEach(function(d) {
				if (d.source.name == skill) {
					linksData.push(d);
				}		
	    	});
	    	return linksData;
	    }

	    var svgbar = d3.select("#bar-chart");
	    function barChart(nodeData, linkedSkills) {
	    	var barheight = 20, padding = 30;

	    	svgbar.attr("height", barheight*linkedSkills.length*2 + barheight + padding*2);
			var width = +svgbar.attr("width"),
				height = +svgbar.attr("height");
			
			var yScale = d3.scaleLinear()
			.domain([1, linkedSkills.length])
			.range([padding + barheight*3/2, height - padding - barheight*3/2]);


			// add circles for linked skills
			svgbar.selectAll(".linked_skills")
			.data(linkedSkills).enter()
			.append("circle")
			.attr("cx", width*2/5)
			.attr("cy", (d, i) => yScale(i+1))
			.attr("r", 5)
			.attr("fill", "lightgrey");

			// add links for skills
			svgbar.selectAll(".skill_links")
			.data(linkedSkills).enter()
			.append("path")
			.attr("d", (d, i) => 
				"M " + width/5 + " " + height/2 +
				" S " + (width/5+10) + " " + (yScale(i+1)+10) + " " +
				width*2/5 + " " + yScale(i+1))
			.attr("stroke-width", 1)
			.attr("stroke", "lightgrey")
			.attr("fill", "none");

			// add circle for clicked skill
			svgbar.append("circle")
			.attr("cx", width/5)
			.attr("cy", height/2)
			.attr("r", 5)
			.attr("fill", color(nodeData.group));

			svgbar.append("text")
			.attr("x", width/5)
			.attr("y", height/2+15)
			.text(nodeData.name)
			.attr("fill", "black")
			.attr("text-anchor", "middle");

			//add bars for lined skills 
			var barScale = d3.scaleLinear()
			.domain(d3.extent(links, d => d.value))
			.range([1, 500]);

			// add 4 quantiles, 25%, 50%, 75%, 100%
			var values = [];
			links.forEach(function(d) {
				values.push(d.value);
			});
			//console.log(values);
			for (var i = 1; i < 5; i++) {
				
				var q = d3.quantile(values.sort(), 0.25*i);
				svgbar.append("line")
					.attr("x1", width*2/5 + 5+ barScale(q))
					.attr("y1", padding)
					.attr("x2", width*2/5 + 5+ barScale(q))
					.attr("y2", height-padding)
					.attr("stroke", "lightgrey")
					.attr("stroke-width", 1)
					.attr("stroke-dasharray", "2 1");

				svgbar.append("text")
					.attr("x", width*2/5 + 5+ barScale(q))
					.attr("y", padding)
					.text("" + 25*i + "%")
					.attr("text-anchor", "middle")
					.attr("font-size", 11)
					.attr("fill", "darkgrey");

			}

			svgbar.selectAll(".linked_bars")
			.data(linkedSkills).enter()
			.append("rect")
			.attr("x", width*2/5+5)
			.attr("y", (d, i) => yScale(i+1)-barheight/2)
			.attr("width", d => barScale(d.value))
			.attr("height", barheight)
			.attr("fill", d => color(d.target.group));

			// add texts
			svgbar.selectAll(".linked_text")
			.data(linkedSkills).enter()
			.append("text")
			.attr("x", width*2/5+10)
			.attr("y", (d, i) => yScale(i+1))
			.text(d => d.target.name)
			.attr("fill", "black");

			// add axis and labels
			svgbar.append("line")
					.attr("x1", width*2/5 + 5)
					.attr("y1", padding + barheight/2)
					.attr("x2", width*2/5 + 5 + 500)
					.attr("y2", padding + barheight/2)
					.attr("stroke", "black")
					.attr("stroke-width", 1);

			svgbar.append("text")
					.attr("x", width*2/5 + barScale(d3.quantile(values.sort(), 1) + 20))
					.attr("y", padding)
					.text("Correlation value")
					.attr("text-anchor", "middle")
					.attr("font-size", 11)
					.attr("fill", "black");
	    }

		// Click event: bar chart
	    node.on("click", function() {
			
			svgbar.selectAll("*").remove();

			var nodeData = this.__data__;
			//console.log(nodeData);
			var linkedSkills = findSkill(nodeData.name);
			linkedSkills = linkedSkills.sort(function(a, b) {
				return d3.descending(a.value, b.value);
			});

			barChart(nodeData, linkedSkills);
			
		});

	    // highlight linked node 
	    function highlight(nodedata) {
	    	var targetname = nodedata.target.name.replace(/\W/g, "_");
	    	//console.log(nodedata)
	    	svg.select("#node_"+targetname)
	    	.append("circle")
	    	.transition()
	    	.delay(100)
	    	.attr("class", "node_highlight")
	    	.attr("r", rscale(nodedata.target.nodesize)+1)
	    	.attr("fill", "none")
	    	.attr("stroke", color(nodedata.target.group))
	    	.attr("stroke-opacity", 0.3)
	    	.attr("stroke-width", 6);

			svg.select("#node_"+targetname)
			.append("text")
			.attr("class", "node_text")
		    .attr("dx", d => rscale(d.nodesize)+1)
		    .attr("dy", 0)
		    .text(d => d.name[0].toUpperCase()+d.name.substring(1));
	    	
	    }

		// hover event: hightlight linked skills 
		node.on("mouseover", function() {
			var nodeData = this.__data__;
			//console.log(nodeData);
			var linkedSkills = findSkill(nodeData.name);

			console.log(svg.select("#node_"+nodeData.name.replace(/\W/g, "_")))

			svg.select("#node_"+nodeData.name.replace(/\W/g, "_"))
			.append("text")
			.attr("class", "node_text")
		    .attr("dx", d => rscale(d.nodesize)+1)
		    .attr("dy", 0)
		    .text(d => d.name[0].toUpperCase()+d.name.substring(1));

			svg.select("#node_"+nodeData.name.replace(/\W/g, "_"))
	    	.append("circle")
	    	.transition()
	    	.delay(100)
	    	.attr("class", "node_highlight")
	    	.attr("r", rscale(nodeData.nodesize)+1)
	    	.attr("fill", "none")
	    	.attr("stroke", "yellow")
	    	.attr("stroke-opacity", 0.3)
	    	.attr("stroke-width", 6)

			console.log(nodeData)	    	
/*	    	nodeData.append("text")
		    .attr("dx", d => rscale(d.nodesize)+1)
		    .attr("dy", 0)
		    .text(d => d.name[0].toUpperCase()+d.name.substring(1));*/

			linkedSkills.forEach(function(d) {
				highlight(d);
			});
		});

		node.on("mouseout", function() {
			svg.selectAll(".node_highlight").remove();
			svg.selectAll(".node_text").remove();
		})

	});

})



function dragstarted(d) {
	if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	d.fx = d.x;
	d.fy = d.y;
}

function dragged(d) {
	d.fx = d3.event.x;
	d.fy = d3.event.y;
}

function dragended(d) {
	if (!d3.event.active) simulation.alphaTarget(0);
	d.fx = null;
	d.fy = null;
}


	</script>
</body>
</html>